#' Averages ERG recordings from ERG lsits
#'
#' This function averages singel ERG recordings from erg lists as generated by import_ERG. It returns a new ERG_LIST object with the additional items AVG, containing a tata.table with the columns Mean, SD, P25 and P75, and graphs, containing graphs of the individual recordings.
#' @param ERG_LIST ERG lists as generated by import_ERG
#' @import foreach
#' @import doParallel
#' @import parallel
#' @import ggplot2
#' @import tidyr
#' @export
#'


average_traces<-function(ERG_LIST,TFLASH,TMAXBWAVE){
  require(foreach)
  require(doParallel)
  require(parallel)
  require(ggplot2)
  require(tidyr)

  numCores <- detectCores()-2
  cl <- makeCluster(numCores)
  registerDoParallel(cl)

  # function for use in par
  parfx<-function(curr){
    if (!is.null(curr)){
      for (j in 1:dim(curr)[2]) {
        curr[,j]<-curr[,j]-curr[1:round((1/ERG_LIST$SampleInterval)*TFLASH),j] #remove offset #fitted(lm(curr[,j]~1)) # remove offset and trend
      }
      curr<-data.frame(rowMeans(curr),apply(curr, 1, sd),t(apply(curr, 1, quantile)[c(2,4),]))
      colnames(curr)<-c("Mean","SD","P25","P75")
    }
    return(curr)
  }

  # calculate averages
  ERG_LIST$TFLASH<-TFLASH
  ERG_LIST$TMAXBWAVE<-TMAXBWAVE
  RECS<-ERG_LIST$TRACES
  REC_AVG<-foreach (i=1:length(RECS)) %dopar% { # do for each recording
    parfx(RECS[i][[1]])
  }
  ERG_LIST$AVG<-REC_AVG
  graph <- vector('list', length(REC_AVG))

  for (i in 1:length(REC_AVG)){
    if (!is.null(REC_AVG[i][[1]])){
      graph[[i]]<-plot_ERG(REC_AVG[i][[1]][seq(1,dim(REC_AVG[i][[1]])[1],10),],ERG_LIST$STIMULUS[i],ERG_LIST$SampleInterval*10)
    }
  }
  ERG_LIST$graphs<-graph

  gc(full=TRUE)
  return(ERG_LIST)
}
